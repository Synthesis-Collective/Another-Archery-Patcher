using System;
using System.Linq;
using System.Threading.Tasks;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;

namespace Another_Archery_Patcher
{
    public class Program
    {
        private static Lazy<Settings> _lazySettings = new();
        private static Settings Settings => _lazySettings.Value; // convenience wrapper

        public static async Task<int> Main(string[] args) {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings("Settings", "settings.json", out _lazySettings)
                .SetTypicalOpen(GameRelease.SkyrimSE, "AnotherArcheryPatcher.esp")
                .Run(args);
        }
        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            if ( Settings == null )
                throw new Exception("Settings were null, something went very wrong during initialization!"); // throw early if settings are null

            if (Settings.UseVerboseLog) { // print out the current settings
                Console.WriteLine("\n--- CONFIGURATION ---");
                Console.WriteLine("Keep Auto-Aim:\t\t\t" + !Settings.GameSettings.DisableAutoaim);
                Console.WriteLine("Keep Ninja Dodge:\t\t" + !Settings.GameSettings.DisableNpcDodge);
                Console.WriteLine("Keep Supersonic:\t\t" + !Settings.MiscTweaks.DisableSupersonic);
                Console.WriteLine("Keep Vanilla Traps:\t\t" + !Settings.MiscTweaks.PatchTraps);

                if (Settings.ProjectileTweaks.Any()) { // print out projectile tweak categories
                    Console.WriteLine("Projectile Categories:\n{");
                    foreach (var tweak in Settings.ProjectileTweaks)
                    {
                        Console.WriteLine("\t\"" + tweak.Identifier + '\"');
                        Console.WriteLine("\t\tPriority:\t" + tweak.Priority);
                        Console.WriteLine("\t\t" + tweak.GetMatchListAsString());
                        Console.WriteLine("\t\tSpeed:\t\t" + tweak.Speed);
                        Console.WriteLine("\t\tGravity:\t" + tweak.Gravity);
                        Console.WriteLine("\t\tImpactForce:\t" + tweak.ImpactForce);
                        Console.WriteLine("\t\tSoundLevel:\t" + tweak.SoundLevel);
                    }
                    Console.WriteLine("}");
                }

                if (Settings.Blacklist.Any()) { // print out blacklisted projectiles
                    Console.Write("Blacklist:{");
                    foreach (var proj in Settings.Blacklist)
                        Console.Write(proj.FormKey.IDString() + ";");
                    Console.Write("}\n");
                }
            }

            Console.WriteLine("\n--- BEGIN PATCHER PROCESS ---"); // begin

            // Handle Game Settings
            if ( Settings.GameSettings.DisableAutoaim ) { // remove auto-aim
                state.PatchMod.GameSettings.Add(new GameSettingFloat(state.PatchMod.GetNextFormKey(), state.PatchMod.SkyrimRelease) { EditorID = "fAutoAimMaxDegrees", Data = 0.0f });          // Add new game setting to patch: "fAutoAimMaxDegrees"
                state.PatchMod.GameSettings.Add(new GameSettingFloat(state.PatchMod.GetNextFormKey(), state.PatchMod.SkyrimRelease) { EditorID = "fAutoAimMaxDistance", Data = 0.0f });         // Add new game setting to patch: "fAutoAimMaxDistance"
                state.PatchMod.GameSettings.Add(new GameSettingFloat(state.PatchMod.GetNextFormKey(), state.PatchMod.SkyrimRelease) { EditorID = "fAutoAimScreenPercentage", Data = 0.0f });    // Add new game setting to patch: "fAutoAimScreenPercentage"
                state.PatchMod.GameSettings.Add(new GameSettingFloat(state.PatchMod.GetNextFormKey(), state.PatchMod.SkyrimRelease) { EditorID = "fAutoAimMaxDegrees3rdPerson", Data = 0.0f }); // Add new game setting to patch: "fAutoAimMaxDegrees3rdPerson"
                Console.WriteLine("Finished removing auto-aim.");
            }
            if ( Settings.GameSettings.DisableNpcDodge ) { // disable npc ninja-dodge
                state.PatchMod.GameSettings.Add(new GameSettingFloat(state.PatchMod.GetNextFormKey(), state.PatchMod.SkyrimRelease) { EditorID = "fCombatDodgeChanceMax", Data = 0.0f });       // Add new game setting to patch: "fCombatDodgeChanceMax"
                Console.WriteLine("Finished patching NPC Ninja Dodge bug.");
            }

            // Handle Projectiles
            var count = 0;
            foreach (var proj in state.LoadOrder.PriorityOrder.Projectile().WinningOverrides())
            {
                if (!IsValidPatchTarget(proj)) continue;
                Console.WriteLine("Processing projectile: " + proj.EditorID);
                Settings.ApplyHighestPriorityStats(state.PatchMod.Projectiles.GetOrAddAsOverride(proj), out var changedValues, out var appliedCategoryIdentifier);
                if (changedValues > 0) {
                    ++count;
                    Console.WriteLine("\tApplied " + changedValues + " values from category \"" + appliedCategoryIdentifier + '\"');
                }
                else
                    Console.WriteLine("\tDidn't apply anything from category \"" + appliedCategoryIdentifier + '\"');
                Console.WriteLine("");
            }
            

            Console.WriteLine("--- END PATCHER PROCESS ---\nProcessed " + count + " projectile records successfully.\n"); // end
        }
        
        /**
         * @brief Checks if a given projectile is not on any blacklist, and is a valid target.
         * @param proj      - The projectile to check.
         * @param editorID  - A string var to assign to the editor ID of the given projectile.
         * @returns bool
         *\n        true    - Projectile is a valid type, and is not on the blacklist.
         *\n        false   - Projectile is not a valid target, skip it.
         */
        private static bool IsValidPatchTarget(IProjectileGetter proj)
        {
            var id = proj.EditorID;
            if (id != null) { // Editor ID is valid, check if projectile type is valid & projectile isn't present on any blacklist.
                // Return true if: type is Arrow and is not blacklisted OR if the patch_traps option is enabled, type is missile, editor ID contains "trap", and is not blacklisted
                return (!Settings.IsBlacklisted(proj) && (proj.Type == Projectile.TypeEnum.Arrow)) || ( Settings.MiscTweaks.PatchTraps && (proj.Type == Projectile.TypeEnum.Missile) && id.Contains("Trap", StringComparison.OrdinalIgnoreCase) );
            }
            return false;
        }
    }
}
