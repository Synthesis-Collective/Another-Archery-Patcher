using System;
using System.Threading.Tasks;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;

namespace Another_Archery_Patcher
{
    public class Program
    {
        private static Lazy<Settings> _lazySettings = new();
        private static Settings Settings => _lazySettings.Value; // convenience wrapper

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings("Settings", "settings.json", out _lazySettings)
                .SetTypicalOpen(GameRelease.SkyrimSE, "AnotherArcheryPatcher.esp")
                .Run(args);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            Console.WriteLine("\n--- BEGIN PATCHER PROCESS ---"); // begin

            // Handle Game Settings
            Settings.GameSettings.AddGameSettingsToPatch(state);

            // Handle Projectiles
            var count = 0;
            foreach (var proj in state.LoadOrder.PriorityOrder.Projectile().WinningOverrides()) {
                if (!IsValidPatchTarget(proj)) continue;
                Console.WriteLine("Processing projectile: " + proj.EditorID);
                Settings.ApplyHighestPriorityStats(state.PatchMod.Projectiles.GetOrAddAsOverride(proj), out var changedValues, out var appliedCategoryIdentifier);
                if (changedValues > 0) {
                    ++count;
                    Console.WriteLine("\tApplied " + changedValues + " values from category \"" + appliedCategoryIdentifier + '\"');
                }
                else
                    Console.WriteLine("\tDidn't apply anything from category \"" + appliedCategoryIdentifier + '\"');

                Console.WriteLine("");
            }


            Console.WriteLine("--- END PATCHER PROCESS ---\nProcessed " + count + " projectile records successfully.\n"); // end
        }

        /**
         * @brief Checks if a given projectile is not on any blacklist, and is a valid target.
         * @param proj      - The projectile to check.
         * @param editorID  - A string var to assign to the editor ID of the given projectile.
         * @returns bool
         * \n        true    - Projectile is a valid type, and is not on the blacklist.
         * \n        false   - Projectile is not a valid target, skip it.
         */
        private static bool IsValidPatchTarget(IProjectileGetter proj)
        {
            var id = proj.EditorID;
            if (id != null) { // Editor ID is valid, check if projectile type is valid & projectile isn't present on any blacklist.
                // Return true if: type is Arrow and is not blacklisted OR if the patch_traps option is enabled, type is missile, editor ID contains "trap", and is not blacklisted
                return (!Settings.IsBlacklisted(proj) && (proj.Type == Projectile.TypeEnum.Arrow)) || (Settings.MiscTweaks.PatchTraps && (proj.Type == Projectile.TypeEnum.Missile) && id.Contains("Trap", StringComparison.OrdinalIgnoreCase));
            }

            return false;
        }
    }
}
