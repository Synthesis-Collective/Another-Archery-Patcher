using System;
using System.Linq;
using System.Threading.Tasks;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;

namespace Another_Archery_Patcher
{
    public class Program
    {
        private static bool HandleProjectile(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, IProjectileGetter proj, ProjectileTweaks tweaks, string logMessage = "")
        {
            try {
                var projectile = state.PatchMod.Projectiles.GetOrAddAsOverride(proj);
                projectile.Speed = tweaks.Stats.Speed;
                projectile.Gravity = tweaks.Stats.Gravity;
                projectile.ImpactForce = tweaks.Stats.ImpactForce;
                projectile.SoundLevel = (uint)tweaks.Stats.SoundLevel;
                if (projectile.Flags.HasFlag(Projectile.Flag.Supersonic) && Settings.MiscTweaks.DisableSupersonic)
                    projectile.Flags &= ~Projectile.Flag.Supersonic;
                if (logMessage.Any())
                    Console.WriteLine(logMessage);
            } catch (Exception?) {
                return false;
            }
            return true;
        }
        private static bool HandleProjectileManual(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, IProjectileGetter proj, ProjectileStats stats, string logMessage = "", string? nameOverride = null)
        {
            try {
                var projectile = state.PatchMod.Projectiles.GetOrAddAsOverride(proj);
                projectile.Speed = stats.Speed;
                projectile.Gravity = stats.Gravity;
                projectile.ImpactForce = stats.ImpactForce;
                projectile.SoundLevel = (uint)stats.SoundLevel;
                if (projectile.Flags.HasFlag(Projectile.Flag.Supersonic) && Settings.MiscTweaks.DisableSupersonic)
                    projectile.Flags &= ~Projectile.Flag.Supersonic;
                if (nameOverride != null)
                    projectile.Name = nameOverride;
                if (logMessage.Any())
                    Console.WriteLine(logMessage);
            } catch (Exception?) {
                return false;
            }
            return true;
        }
        private static bool HandleRecord(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, IProjectileGetter proj, string id, ProjectileTweaks tweak, string log_message = "")
        {

            if (Settings.MiscTweaks.DisableGravityBloodcursed && Settings.MiscTweaks.BloodcursedId.Contains(id, StringComparer.OrdinalIgnoreCase))
            {
                return HandleProjectileManual(state, proj,
                    new ProjectileStats(tweak.Stats.Speed, 0.0f, tweak.Stats.ImpactForce,
                        tweak.Stats.SoundLevel), "Finished Processing Bloodcursed arrow: \"" + id + "\"");
            }
            return HandleProjectile(state, proj, tweak, "Finished Processing: \"" + id + "\"");
        }
        private static bool IsValidPatchTarget(IProjectileGetter proj, out string editorId)
        {
            if (proj.EditorID != null) { // Editor ID is valid, check if projectile type is valid & projectile isn't present on any blacklist.
                editorId = proj.EditorID;
                // Return true if: type is Arrow and is not blacklisted OR if the patch_traps option is enabled, type is missile, editor ID contains "trap", and is not blacklisted
                return ( proj.Type == Projectile.TypeEnum.Arrow && !Settings.Blacklist.IsMatch(editorId)) || ( Settings.MiscTweaks.PatchTraps && proj.Type == Projectile.TypeEnum.Missile && proj.EditorID.Contains("Trap", StringComparison.OrdinalIgnoreCase) && !Settings.Blacklist.IsMatch(editorId) );
            }
            editorId = "";
            return false;
        }


        private static Lazy<TopLevelSettings> _lazySettings = new();
        private static TopLevelSettings Settings => _lazySettings.Value; // convenience wrapper

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings("Settings", "settings.json", out _lazySettings)
                .SetTypicalOpen(GameRelease.SkyrimSE, "AnotherArcheryPatcher.esp")
                .Run(args);
        }
        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            if (Settings.UseVerboseLog) {
                Console.WriteLine("\n--- CONFIGURATION ---");
                Console.WriteLine("Remove Auto-Aim:\t\t" + Settings.GameSettings.DisableAutoaim);
                Console.WriteLine("Fix Ninja Dodge:\t\t" + Settings.GameSettings.DisableNpcDodge);
                Console.WriteLine("Remove Supersonic:\t\t" + Settings.MiscTweaks.DisableSupersonic);
                Console.WriteLine("Patch Trap Projectiles:\t\t" + Settings.MiscTweaks.PatchTraps);

                Console.Write("Projectile Tweaks:{");
                foreach (var tweak in Settings.ProjectileTweaks)
                    Console.Write('\n' + tweak.GetVarsAsString());
                Console.WriteLine("}");
                if (Settings.Blacklist.Enabled)
                {
                    Console.Write("Blacklist: {");
                    foreach (var id in Settings.Blacklist.Matchlist)
                        Console.Write("\n\t" + id.Name + ( id.Required ? "[!]" : "" ));
                    foreach (var id in Settings.Blacklist.Record)
                        Console.Write("\n\t" + id);
                    Console.WriteLine("\n}");
                }
            }

            Console.WriteLine("\n--- BEGIN PATCHER PROCESS ---");
            var gmstModified = false;
            if ( Settings == null ) throw new Exception("Settings were null! (How did this happen?)"); // throw early if settings are null
            if ( Settings.GameSettings.DisableAutoaim ) {
                state.PatchMod.GameSettings.Add(new GameSettingFloat(state.PatchMod.GetNextFormKey(), state.PatchMod.SkyrimRelease) { EditorID = "fAutoAimMaxDegrees", Data = 0.0f });          // Add new game setting to patch: "fAutoAimMaxDegrees"
                state.PatchMod.GameSettings.Add(new GameSettingFloat(state.PatchMod.GetNextFormKey(), state.PatchMod.SkyrimRelease) { EditorID = "fAutoAimMaxDistance", Data = 0.0f });         // Add new game setting to patch: "fAutoAimMaxDistance"
                state.PatchMod.GameSettings.Add(new GameSettingFloat(state.PatchMod.GetNextFormKey(), state.PatchMod.SkyrimRelease) { EditorID = "fAutoAimScreenPercentage", Data = 0.0f });    // Add new game setting to patch: "fAutoAimScreenPercentage"
                state.PatchMod.GameSettings.Add(new GameSettingFloat(state.PatchMod.GetNextFormKey(), state.PatchMod.SkyrimRelease) { EditorID = "fAutoAimMaxDegrees3rdPerson", Data = 0.0f }); // Add new game setting to patch: "fAutoAimMaxDegrees3rdPerson"
                Console.WriteLine("Finished removing auto-aim.");
                gmstModified = true;
            }
            if ( Settings.GameSettings.DisableNpcDodge ) {
                state.PatchMod.GameSettings.Add(new GameSettingFloat(state.PatchMod.GetNextFormKey(), state.PatchMod.SkyrimRelease) { EditorID = "fCombatDodgeChanceMax", Data = 0.0f });       // Add new game setting to patch: "fCombatDodgeChanceMax"
                Console.WriteLine("Finished patching NPC Ninja Dodge bug.");
                gmstModified = true;
            }
            var count = 0;
            foreach ( var proj in state.LoadOrder.PriorityOrder.Projectile().WinningOverrides() )
            {
                // iterate through winning projectile overrides (this includes all projectile records added by mods)
                if (!IsValidPatchTarget(proj, out string id)) continue;

                if ( id.Contains("Trap", StringComparison.OrdinalIgnoreCase) ) // Priority 2 - Trap Projectiles
                    count += (id.Contains("TrapDweBallista", StringComparison.OrdinalIgnoreCase) ? HandleProjectileManual(state, proj, new ProjectileStats(6400.0f, 0.69f, 75.0f, SoundLevel.VeryLoud), "Finished Processing Trap: \"" + id + '\"') : HandleProjectileManual(state, proj, new ProjectileStats(3000.0f, 0.0f, 0.2f, SoundLevel.Normal), "Finished processing trap: \"" + id + '\"')) ? 1 : 0;
                else
                {
                    var allowPartial = true;
                    foreach (var tweak in Settings.ProjectileTweaks.Where(tweak => tweak.IsPerfectMatch(id)))
                        allowPartial = !HandleRecord(state, proj, id, tweak, "Finished Processing: " + id);
                    if (!allowPartial)
                        ++count;
                    else
                        count += Settings.ProjectileTweaks.Where(tweak => tweak.IsMatch(id)).Sum(tweak => HandleRecord(state, proj, id, tweak) ? 1 : 0);
                }
            }
            Console.WriteLine("--- END PATCHER PROCESS ---");
            if (!Settings.UseVerboseLog)
                return;
            switch (count)
            {
                case 0 when !gmstModified:
                    Console.WriteLine("[WARNING]\tNo records were modified! (Check your settings, is anything enabled?)");
                    break;
                case > 0:
                    Console.WriteLine("Processed " + count + " records.");
                    break;
            }
        }
    }
}
